<html><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>
  Langages, interprétation, compilation - DM - Kawa
</title>
<style type="text/css">
h4 { text-align: left; float: none; width: auto;}
table { align: center; table-layout: fixed; border-collapse: collapse; margin: 1em auto; }
th { text-align: left; }
td, th { padding: 0 1em; }
tbody tr:nth-child(odd) { background-color: #cccccc; }
body { 
    font-family:verdana, helvetica, sans-serif;
    font-size: 16px;
}

#global {
    position: relative;
    width: 800px;
    margin: 0 auto;
    padding: 0;
}

#header {
    position: relative;
    margin: 5px 0px;
}

#header p {
    font-size: 20px;
    font-style: italic;
    margin-top: 0px;
}

#content {
    margin: 0 30px;
    text-align: justify;
    text-justify: inter-word;
}

h1 {
    letter-spacing: 0px;
    font-size: 24px;
    text-align: left;
    margin-bottom: 5px;
}

h2 {
    margin: 20px 0px;
    border-bottom: 2px solid #888;
    font-size: 20px;
}

h3 {
    margin: 10px 30px;
    width: 75%;
    color: #888;
    border-bottom: 2px solid #888;
    font-size: 16px;
}

table {
    margin: auto;
    border-collapse: collapse;
}

th, td {
    border: 1px solid;
    padding: 5px 10px;
}


a {
    color: #008;
    text-decoration: none;
    font-weight: bold;
}

a:link {
    color: #f70;
}
a:visited {
    color: #f90;
}
a:hover {
    color: #f90;
    text-decoration: underline;
}

tt {
        color:purple;
}

pre {
        color:purple;
}
</style>
</head>

<body>
  <div id="global">
    <div id="header">
      <h1>Langages, interprétation, compilation<br>
	DM - <tt>Kawa</tt>
      </h1> 
    </div>

    <div id="content">

      <p>
        L'objectif de ce DM est de construire un interprète pour un petit
        langage objet inspiré de Java.
      </p>

      <h2> Description du langage <tt>Kawa</tt> </h2>
      <p>
        Un programme <tt>Kawa</tt> est formé par une série de déclarations
        de variables globales, suivie d'une série de définitions de classes,
        suivie d'une bloc d'instruction principal à exécuter.
      </p>

      <p>
        La déclaration d'une variable mentionne son type et son nom.
</p><pre>  var int n;
  var point p;
</pre>
        Un type peut être un type de base <tt>int</tt> ou <tt>bool</tt>,
        ou un nom de classe.

        La définition d'une classe comporte d'abord des déclarations
        d'attributs, typés comme les variables, puis des définitions de 
        méthodes. Chaque définition de méthode comporte un type de retour
        (ou la mention spéciale <tt>void</tt> si la méthode ne renvoie rien),
        une liste de paramètres et leurs types, et une séquence d'instructions
        à exécuter.
<pre> 
  class point {
    attribute int x;
    attribute int y;

    method void constructor(int x, int y) {
      this.x = x;
      this.y = y;
    }

    method int size() { return this.x+this.y; }
  }
</pre>
Le bloc de code principal est placé entre accolades, après le mot-clé
<tt>main</tt>.
<pre>  main {
    p = new point(1, 2);
    p.x = p.x + p.y;
    print(p.size());
  }
</pre>
La construction d'un nouvel objet se fait avec l'opérateur <tt>new</tt>
suivi d'un nom de classe, et éventuellement d'une séquence d'arguments
entre parenthèses. Par défaut, les attributs de l'objet créé ne sont pas
initialisés. Lorsque l'on fournit une liste d'arguments (fût-elle
vide), la création de l'objet est suivie de l'appel de la méthode
<tt>constructor</tt> de la classe concernée avec les arguments fournis,
sur l'objet nouvellement créé.
Note : dans ce cas, la méthode <tt>constructor</tt> doit exister, et
son retour doit être <tt>void</tt>.
<p></p>

      <h2> Travail à réaliser (base) </h2>

      <p>
        Le DM est découpé en trois parties :
        </p><ol>
          <li> <a href="#syntaxe">analyse syntaxique</a>, </li>
          <li> <a href="#types">vérification des types</a>, </li>
          <li> <a href="#interprete">interprétation</a>, </li>
        </ol>
        auxquelles s'ajoutent des <a href="#extensions">extensions</a> 
        optionnelles.
      <p></p>
      
      <h3> Consignes </h3>

      <p>
        On fournit un <a href="https://public.lmf.cnrs.fr/~blsk/CompilationLDD3/kawa.zip">squelette de code</a> contenant
        les éléments suivants.
        <table>
          <thead>
            <tr><th>Fichier</th><th>Contenu</th><th>Commentaire</th></tr>
          </thead>
          <tbody>
            <tr>
              <td><tt>kawa.ml</tt></td>
              <td>syntaxe abstraite</td>
              <td></td>
            </tr>
            <tr>
              <td><tt>kawalexer.mll</tt></td>
              <td>analyse lexicale</td>
              <td>à compléter (ocamllex) </td>
            </tr>
            <tr>
              <td><tt>kawaparser.mly</tt></td>
              <td>analyse grammaticale</td>
              <td>à compléter (menhir) </td>
            </tr>
<!--           
            <tr>
              <td><tt>kawapp.ml</tt></td>
              <td>module d'affichage</td>
              <td></td>
            </tr>
            <tr>
              <td><tt>kawacat.ml</tt></td>
              <td>programme intermédiaire</td>
              <td></td>
            </tr>
-->
            <tr>
              <td><tt>typechecker.ml</tt></td>
              <td>vérification des types</td>
              <td>à compléter (caml) </td>
            </tr>
            <tr>
              <td><tt>interpreter.ml</tt></td>
              <td>interprétation</td>
              <td>à compléter (caml) </td>
            </tr>
            <tr>
              <td><tt>kawai.ml</tt></td>
              <td>programme principal</td>
              <td></td>
            </tr>
            <tr>
              <td><tt>dune</tt>/<tt>dune-project</tt></td>
              <td>configuration</td>
              <td></td>
            </tr>
            <tr>
              <td><tt>tests</tt></td>
              <td>dossier de tests</td>
              <td>à compléter (kawa) </td>
            </tr>
          </tbody>
        </table>
      </p>

      <p>
        Votre travail principal consiste à compléter les quatre fichiers
        <tt>kawalexer.mll</tt>, <tt>kawaparser.mly</tt>,
        <tt>typechecker.ml</tt> et <tt>interpreter.ml</tt>
        en respectant les descriptions données dans la suite de cette page.
        Vous obtiendrez alors avec le programme <tt>kawai</tt> un interprète
        complet pour <tt>Kawa</tt>.
        On s'attend à ce que vous ajoutiez également de nouveaux tests.
      </p>

      <p>
        Vous pouvez inclure à votre projet autant d'extensions que vous le
        souhaitez. Les extensions sont facultatives, mais si vous en réalisez
        elles viendront renforcer votre note.
      </p>

      <p>
        Vous pouvez travailler seul ou en binôme. Votre projet devra être
        rendu à votre encadrant de TP. Joignez à votre projet un rapport
        décrivant ce qui a été réalisé, ce qui fonctionne ou non, et les
        difficultés que vous avez pu rencontrer. Le rapport doit également
        détailler les éventuelles extensions que vous avez traitées.
        Le rapport peut prendre la forme d'un simple fichier
        <tt>README.txt</tt>.
      </p>

      <p>
        Le squelette de code est conçu pour traiter correctement un programme
        minimal. En plus de ces éléments, vous pouvez réutiliser sans 
        limitations les fragments de code présentés dans le cours.
        Attention en revanche : tout emprunt de code d'une autre source que le
        cours doit être documenté dans votre rapport.
      </p>

      <h3> Recommandations </h3>

      <p>
        Votre progression dans ce projet peut se représenter sur deux axes :
        </p><ol>
          <li> les étapes successives du programme d'interprétation, qui
            correspondent aux différents fichiers à compléter,</li>
          <li> les différentes constructions du langage <tt>Kawa</tt>,
            qui correspondent aux différents cas de chaque fonction 
            principale. </li>
        </ol>
        Vous pouvez vous figurer un tableau à double entrée comme le suivant.
        <table>
          <thead>
            <tr><th></th><th><tt>kawalexer</tt></th><th><tt>kawaparser</tt></th><th><tt>typechecker</tt></th><th><tt>interpreter</tt></th></tr>
          </thead>
          <tbody>
            <tr><th>Arithmétique</th><td></td><td></td><td></td><td></td></tr>
            <tr><th>Variables</th><td></td><td></td><td></td><td></td></tr>
            <tr><th>Instructions</th><td></td><td></td><td></td><td></td></tr>
            <tr><th>Classes et attributs</th><td></td><td></td><td></td><td></td></tr>
            <tr><th>Méthodes</th><td></td><td></td><td></td><td></td></tr>
            <tr><th>Héritage</th><td></td><td></td><td></td><td></td></tr>
        </tbody></table>
        Vous pouvez organiser votre travail selon l'un ou l'autre de ces axes.
        <ul>
          <li>
            En travaillant colonne par colonne, vous suivez les chapitres du
            cours (et les sections de ce sujet), et vous complétez un fichier
            avant de commencer le suivant.
          </li><li>
            En travaillant ligne par ligne, vous vous concentrez sur les
            différents aspects du langage l'un après l'autre, et progressez
            en parallèle dans les quatre fichiers.
          </li>
        </ul>
        La deuxième stratégie a un avantage : elle permet de réaliser
        rapidement des tests, en sélectionnant des programmes <tt>Kawa</tt>
        contenant exactement les aspects traités.
      <p></p>

      <p>
        Remarquez que dans l'étape intermédiaire où on a les classes et les
        attributs, mais pas encore les méthodes, le langage ne permet de créer
        un objet que d'une seule manière : avec un nom de classe mais pas
        d'arguments.
        </p><pre>  p = new point;</pre>
        Les attributs sont alors systématiquement non initialisés.
        Une fois les méthodes ajoutées en revanche, on peut inclure la création
        d'objets initialisés par un constructeur.
      <p></p>

      <p>
        Quelle que soit votre stratégie de progression, il est important de
        tester votre programme à chaque étape avant de passer à la suivante.
        </p><ul>
<!--       
          <li>
            Le programme intermédiaire <tt>kawacat</tt> pourra vous servir à
            tester votre analyse syntaxique. Il prend en entrée un nom de
            fichier <tt>.kwa</tt>, fait l'analyse syntaxique du contenu de
            ce fichier, et écrit dans un fichier <tt>.kwa.cat</tt> un
            programme correspondant à l'AST produit par l'analyse.
            L'afficheur utilise plus de parenthèses que nécessaire, pour que
            vous puissiez observer certaines des priorités réalisées par votre 
            analyseur.
          </li>
-->
          <li>
            Le programme principal <tt>kawai</tt> est un interprète
            <tt>Kawa</tt>. Il prend en entrée un nom de fichier
            <tt>.kwa</tt>, fait son analyse syntaxique, vérifie sa cohérence
            de types, et l'interprète.
          </li>
          <li>
            Le dossier <tt>tests</tt> contients quelques tests, à compléter
            par les vôtres.
          </li>
        </ul>
      <p></p>

      <p>
        L'ensemble du projet peut être résolu en 400 lignes de code environ,
        avec quatre fichiers de tailles comparables.
      </p>

      <h2 id="syntaxe"> 1. Analyse syntaxique </h2>

      <p> La première tâche consiste à réaliser l'analyse syntaxique d'un
        programme et à produire l'arbre de syntaxe abstraite associé.
        Vous devez pour cela compléter les fichiers
        <tt>kawalexer.mll</tt> et <tt>kawaparser.mly</tt>.
        Vous devez aussi expurger votre analyseur syntaxique de toutes ses
        ambiguïtés (à l'aide de priorités).
      </p>

      <h3> Syntaxe concrète </h3>
      <p>
        La syntaxe concrète de <tt>Kawa</tt> est définie par les règles
        suivantes (des explications de certaines notations viennent juste
        après).
</p><pre>   &lt;program&gt; ::= &lt;var_decl&gt;* &lt;class_def&gt;* &lt;main&gt; eof

 &lt;class_def&gt; ::= class ident [extends ident]? { &lt;attr_decl&gt;* &lt;method_def&gt;* }

  &lt;var_decl&gt; ::= var &lt;type&gt; ident ;
 &lt;attr_decl&gt; ::= attribute &lt;type&gt; ident ;

      &lt;type&gt; ::=  int 
              |   bool
              |   ident
              |   void
 
&lt;method_def&gt; ::= method &lt;type&gt; ident ( [&lt;type&gt; ident /,]* ) { &lt;var_decl&gt;* &lt;instr&gt;* }

      &lt;expr&gt; ::=  n 
              |   true 
              |   false
              |   this
              |   &lt;mem&gt;
              |   &lt;uop&gt; &lt;expr&gt;
              |   &lt;expr&gt; &lt;bop&gt; &lt;expr&gt;
              |   ( &lt;expr&gt; )
              |   new ident
              |   new ident ( [&lt;expr&gt; /,]* )
              |   &lt;expr&gt; . ident ( [&lt;expr&gt; /,]* )

       &lt;mem&gt; ::=  ident
              |   &lt;expr&gt; . ident

     &lt;instr&gt; ::=  print ( &lt;expr&gt; ) ;
              |   &lt;mem&gt; = &lt;expr&gt; ;
              |   if ( &lt;expr&gt; ) { &lt;instr&gt;* } else { &lt;instr&gt;* }
              |   while ( &lt;expr&gt; ) { &lt;instr&gt;* }
              |   return &lt;expr&gt; ;
              |   &lt;expr&gt; ;
         
       &lt;uop&gt; ::=  -  |  !
       &lt;bop&gt; ::=  +  |  -   |  *  |  /   |  %
              |  ==  |  !=  |  &lt;  |  &lt;=  |  &amp;&amp;   |  ||
</pre>
      <p></p>

      <p>
        On prend comme symboles terminaux :
        </p><ul>
          <li> les constantes entières positives, désignées dans les règles
            par <tt>n</tt>, </li>
          <li> les identifiants alpha-numériques, désignés dans les
            règles par <tt>ident</tt>,</li>
          <li> les mots-clés <tt>true</tt>, <tt>false</tt>,
            <tt>var</tt>, <tt>attribute</tt>, <tt>method</tt>,
            <tt>class</tt>, <tt>new</tt>, <tt>this</tt>,
            <tt>if</tt>, <tt>else</tt>, <tt>while</tt>,
            <tt>return</tt>, <tt>print</tt>,
            <tt>int</tt>, <tt>bool</tt>, <tt>void</tt>, </li>
          <li> les symboles <tt>=</tt>, <tt>+</tt>, <tt>-</tt>, <tt>*</tt>, 
            <tt>/</tt>, <tt>==</tt>, <tt>!=</tt>, <tt>&lt;</tt>, 
            <tt>&lt;=</tt>, <tt>&amp;&amp;</tt>, <tt>||</tt>, <tt>(</tt>,
            <tt>)</tt>, <tt>{</tt>, <tt>}</tt>, <tt>;</tt>, 
            <tt>.</tt>, <tt>,</tt>, </li>
          <li> un symbole spécial <tt>eof</tt> (fin de fichier) </li>
        </ul>
      <p></p>

      <p>
        On prend comme symboles non terminaux principaux :
        </p><ul>
          <li> <tt>&lt;program&gt;</tt> pour un programme complet </li>
          <li> <tt>&lt;class_def&gt;</tt> et <tt>&lt;method_def&gt;</tt> les
            définitions de classes et de méthodes </li>
          <li> <tt>&lt;var_decl&gt;</tt> et <tt>&lt;attribute_decl&gt;</tt>
            pour les déclarations de variables et d'attributs </li>
          <li> <tt>&lt;type&gt;</tt> pour un type </li>
          <li> <tt>&lt;expr&gt;</tt> pour une expression </li>
          <li> <tt>&lt;mem&gt;</tt> pour un accès mémoire </li>
          <li> <tt>&lt;instr&gt;</tt> pour une instruction </li>
          <li> <tt>&lt;uop&gt;</tt> et <tt>&lt;bop&gt;</tt> pour les
            opérateurs unaires et binaires </li>
        </ul>
        Vous pourrez en introduire d'autres en fonction des besoins, pour
        reproduire les différents motifs de la grammaire.
        Rappel : la notion d'« accès mémoire » sert ici à regrouper les accès
        à une variable ou à un attribut d'un objet (que ce soit pour lecture
        ou pour écriture).
      <p></p>
      
      <p>
        Dans les règles de grammaire, on adopte les notations supplémentaires
        suivantes :
        </p><ul>
          <li> <tt>[m]?</tt>
            pour désigner la présence optionnelle du motif <tt>m</tt> </li>
          <li> <tt>[m]*</tt>
            pour désigner une répétition éventuellement vide du motif <tt>m</tt> </li>
          <li> <tt>[m/,]*</tt>
            pour désigner une répétition éventuellement vide du motif, <tt>m</tt>,
            où les occurrences sont séparées par <tt>,</tt> </li>
        </ul>

      <p>
        En outre, on autorise des commentaires (non imbriqués) délimités par les
        séquences <tt>/*</tt> et <tt>*/</tt>, ou par <tt>//</tt> et une fin de ligne.
      </p>

      <p>
        On conserve toutes les conventions d'écriture et priorités des
        opérateurs en vigueur dans les langages usuels (par exemple, en java).
      </p>

      <h3> Syntaxe abstraite </h3>

      <p>
        La syntaxe abstraite retranscrit directement la
        plupart des constructions de la syntaxe concrète.
        Elle est principalement définie par les types suivants :
        </p><ul>
          <li> <tt>program</tt> pour les programmes complets </li>
          <li> <tt>class_def</tt> et <tt>method_def</tt> pour les définitions de
            classes et de méthodes </li>
          <li> <tt>expr</tt> et <tt>mem_access</tt> pour les expressions et accès </li>
          <li> <tt>instr</tt> et <tt>seq</tt> pour les instructions et séquences </li>
          <li> <tt>typ</tt> pour les types </li>
        </ul>
        Apparaissent également des types <tt>uop</tt> et <tt>bop</tt> qui
        énumèrent les opérateurs.
      <p></p>


      <h2 id="types"> 2. Vérification des types </h2>

      <p>
        La vérification des types en <tt>Kawa</tt> doit vérifier en
        particulier que chaque expression est cohérente, que chaque accès à
        un champ et chaque appel de méthode est bien permis par la classe de
        l'objet concerné, et que chaque appel et chaque affectation est faite
        avec des expressions dont le type statique est bien un sous-type du
        type attendu.
        Elle doit produire une erreur dans (au moins) les cas suivants :
        </p><ul>
          <li> expression incohérente, </li>
          <li> référence à une variable inexistante, </li>
          <li> référence à un champ d'une valeur qui n'est pas un objet, </li>
          <li> référence à un nom de champ inexistant, </li>
          <li> présence d'un <tt>return</tt> dans une fonction ne renvoyant
            pas de résultat. </li>
        </ul>
      <p></p>

      <h3> Mise en place </h3>
        
      <p>
        Le fichier <tt>typeckecker.ml</tt> contient :
        </p><ul>
          <li> une fonction <tt>typecheck_prog : program -&gt; unit</tt> qui
            termine lorsque le programme donné en argument est correct,
            et qui produit une erreur sinon, </li>
          <li> deux fonctions <tt>type_expr</tt> et <tt>type_mem_access</tt>
            qui prennent qui prend en arguments une expression (resp. un accès
            mémoire) et un environnement de typage, et qui renvoient le type
            de l'expression ou de l'accès, ou produisent une erreur en cas
            d'incohérence, </li>
          <li> une fonction <tt>check</tt> qui prend en paramètre une
            expression, un type attendu et un environnement, et qui vérifie
            que l'expression est bien typée, et du type attendu, et produit
            une erreur sinon, </li>
          <li> deux fonctions <tt>check_instr</tt> et <tt>check_seq</tt>,
            qui prenennt en paramètre une instruction ou séquence, un type
            de retour attendu (<tt>TVoid</tt> si pas de retour attendu) et
            un environnement de typage, qui vérifie que l'instruction 
            est cohérente et produit une erreur sinon. </li>
        </ul>
        Votre tâche consiste à compléter ces six fonctions, en respectant
        les règles de typage détaillées ci-dessous. Vous devrez également
        ajouter deux fonctions <tt>check_class</tt> et <tt>check_mdef</tt>
        pour typer respectivement les définitions de classes et de méthodes.
      <p></p>

      <p>
        Notes supplémentaires sur les environnements de typage :
        </p><ul>
          <li> lors du typage du code d'une classe <tt>C</tt>,
            on suppose que l'environnement de typage contient une variable
            spéciale <tt>this</tt> de type <tt>C</tt>, </li>
          <li> lors du typage du code d'une méthode, on suppose que
            l'environnement de typage contient des entrées pour les paramètres
            et les variables locales de cette méthode, </li>
          <li> toutes les fonctions ont accès à la liste des classes définies
            par le programme à analyser, et peuvent donc, connaissant un nom de
            classe, aller en extraire les informations de typage associées. </li>
        </ul>
      <p></p>

      <p>
        Syntaxe abstraite des types : le squelette de code contient la définition
        suivante pour la représentation des types.
</p><pre>  type typ =
    | TVoid
    | TInt
    | TBool
    | TClass of string
</pre>
Bien qu'on ne considère pas <tt>void</tt> comme un vrai type,
on a inclus dans cette représentation un constructeur <tt>TVoid</tt>.
Ce choix va simplifier l'écriture du vérificateur de types, en évitant
notamment de traiter séparément le cas d'une méthode qui renvoie une valeur
(d'un "vrai" type) et le cas d'une méthode qui ne produit pas de valeur
(cas <tt>void</tt>).
Alternativement, on aurait pu représenter <tt>void</tt> par <tt>None</tt>,
et les vrais types par <tt>Some ...</tt>.
      <p></p>

      <h3> Règles de typage </h3>
      <p>
        Remarque : pour alléger l'écriture de ces règles, on y utilise autant
        que possible la syntaxe concrète.
      </p>

<p>
  On note </p><pre>  t' &lt;: t</pre> lorsque <tt>t'</tt> est un sous-type
  de <tt>t</tt>, c'est-à-dire lorsque
  <ul>
    <li> <tt>t'</tt> est égal à <tt>t</tt>, </li>
    <li> ou <tt>t'</tt> est une sous-classe, directe ou indirecte, de <tt>t</tt>.
  </li></ul>
<p></p>

<p>
  Constantes, où <tt>n</tt> désigne une constante entière.
</p><pre>  ------------    ----------------    -----------------
  E |- n : int    E |- true : bool    E |- false : bool
</pre>
<p></p>

<p>
  Opérations unaires.
</p><pre>  E |- e : int       E |- e : bool       
  -------------    -----------------
  E |- -e : int    E |- not e : bool  
</pre>
<p></p>

<p>
  Opérations binaires. Les opérations et comparaisons arithmétiques
  travaillent sur des entiers. Le test d'égalité est polymorphe mais
  demande des opérandes homogènes.
</p><pre>  E |- e1 : int     E |- e2 : int      E |- e1 : int     E |- e2 : int
  -------------------------------      -------------------------------
        E |- e1 + e2 : int                  E |- e1 &lt; e2 : bool

  E |- e1 : t     E |- e2 : t
  ---------------------------
     E |- e1 == e2 : bool
</pre>
<p></p>

<p>
  Variables.
</p><pre>   E(x) = t       E |- e : C     C(x) = t
  ----------      -----------------------
  E |- x : t           E |- e.x : t
</pre>
<p></p>

<p>
  Appels de méthodes et de constructeurs (avec dans les prémisses, une 
  vérification à faire pour tout <tt>k</tt>).
</p><pre>     C existe
  --------------
  E |- new C : C

  C(constructor) = (t1 x ... x tN) -&gt; void      E |- ek : tk'      tk' &lt;: tk
  --------------------------------------------------------------------------
                         E |- new C(e1, ..., eN) : C

  E |- e : C     C(f) = (t1 x ... x tN) -&gt; t      E |- ek : tk'      tk' &lt;: tk
  ----------------------------------------------------------------------------
                         E |- e.f(e1, ..., eN) : t
</pre>
À noter dans les deux dernières règles : en l'absence d'héritage la condition
de sous-typage <tt>tk' &lt;: tk</tt> est remplacée par un simple test d'égalité.
<p></p>

<p>
  Instructions
</p><pre>   E |- e : int        E |- e : void       E |- e : t   t = ret
  --------------       -------------       --------------------
  E |- print(e);          E |- e;             E |- return e;

  E |- e : t    t &lt;: E(x)        E |- e1 : C      E |- e2 : t      t &lt;: C(x)
  -----------------------        -------------------------------------------
        E |- x = e;                           E |- e1.x = e2;

  E |- e : bool     E |- s1     E |- s2       E |- e : bool     E |- s
  -------------------------------------       ------------------------
     E |- if (e) { e1 } else { e2 }             E |- while (e) { s }
</pre>
<p></p>
      
      <h2 id="interprete"> 3. Interprétation </h2>

      <p>
        L'interprétation d'un programme <tt>Kawa</tt> doit exécuter la
        séquence d'instructions principale. À mesure de cette exécution,
        il faudra créer ou modifier des objets en mémoire, et afficher
        des valeurs.
      </p>

      <p>
        L'évaluation d'une expression produite une valeur de l'une des
        quatre sortes suivantes :
        </p><ul>
          <li> constante entière, </li>
          <li> constante booléenne, </li>
          <li> constante <tt>null</tt> (lorsqu'une valeur est indéfinie), </li>
          <li> objet. </li>
        </ul>
        Un objet est composé d'un nom de classe, et d'une table donnant une
        valeur (éventuellement <tt>null</tt>) à chaque attribut.
      <p></p>

      <h3> Mise en place </h3>

      <p>
        Le fichier <tt>interpreter.ml</tt> contient un fragment d'interprète,
        que vous devez compléter. Vous y trouverez en particulier :
        </p><ul>
          <li> une fonction <tt>exec_prog</tt>, qui prend en paramètre un
            programme <tt>Kawa</tt> et l'exécute, </li>
          <li> une fonction <tt>eval_seq</tt>, qui exécute une séquence
            d'instructions, </li>
          <li> une fonction <tt>eval_call</tt>, qui évalue un appel de
            méthode. </li>
        </ul>
        Les fonctions <tt>eval_seq</tt> et <tt>eval_call</tt> accèdent toutes
        les deux à un environnement global <tt>env</tt> mutable, qui associe
        une valeur à chaque variable gloable et est mis à jour lors des
        opérations d'affectation.
        En outre, <tt>eval_seq</tt> utilise un environnement local 
        <tt>lenv</tt>, mutable également, qui associe une valeur à chaque
        paramètre de fonction et chaque variable locale de l'appel en cours.
      <p></p>

      <p>
        Le fragment de code fourni fait les choix techniques suivants.
        </p><ul>
          <li> L'environnement local et l'environnement global sont réalisés
            par des tables de hachage, dont les clés sont les identifiants des
            variables et des paramètres. À chaque clé, la table associe une
            valeur, qui est <tt>null</tt> pour une variable non initialisée.
          </li>
          <li> Chaque objet est représenté un record caml avec deux champs :
            le premier est le nom de la classe à laquelle appartient l'objet,
            le deuxième est une table de hachage dont les clés sont les noms
            des attributs, et qui donne la valeur associée à chacun.
          </li>
        </ul>
        Vous avez le droit de modifier ces choix techniques si vous préférez
        un style différent.
      <p></p>

      <h3> Sémantique </h3>

      <p>
        L'interprétation doit suivre les principes suivants.
      </p>

      <p> Valeurs et opérations de base.
        </p><ul>
          <li> Les constantes, entières ou booléennes, sont leur
            propre valeur. </li>
          <li> La valeur <tt>null</tt> caractérise les variables ou attributs
            non initialisés, et le résultat d'une fonction <tt>void</tt>. </li>
          <li> Les opérations et comparaisons arithmétiques ont leur
            signification habituelle. L'ordre d'évaluation des opérandes d'une
            opération binaire n'est généralement pas spécifié. </li>
          <li> Rappel : les opérations <tt>&amp;&amp;</tt> et <tt>||</tt>
            sont paresseuses. Elles évaluent en premier leur opérande de
            gauche, et n'évaluent celui de droite que si nécessaire. </li>
          <li> Les opérations <tt>==</tt> et <tt>!=</tt> testent l'égalité
            physique de leurs opérandes. Elles obéissent aux critères
            suivants :
            <ul>
              <li> chaque constante est égale à elle-même, </li>
              <li> deux objets sont égaux si el seulement s'ils sont
                physiquement le même objet, </li>
              <li> des valeurs de natures différentes ne sont jamais
                égales. </li>
            </ul>
          </li>
        </ul>
      <p></p>

      <p>
        Classes et objets.
        </p><ul>
          <li> Une définition de classe définit un type et des méthodes.
            L'ensemble des classes définies dans un programme est inclus dans
            le contexte de l'interprète. </li>
          <li> Chaque classe hérite optionnellement d'une autre classe appelée
            sont parent. Elle en reprend alors les déclarations d'attributs et
            les définitions de méthodes. </li>
          <li> L'opération <tt>new</tt> appliquée uniquement à un nom de
            classe <tt>cn</tt> crée un nouvel objet de la classe <tt>cn</tt>,
            et renvoie cet objet. Les attributs de l'instance créée ne sont
            pas initialisés (leur consultation doit renvoyer <tt>null</tt>).
          </li><li> L'opération <tt>new</tt> appliquée à un nom de classe <tt>cn</tt>
            et une séquence de paramètre <tt>(e1, ..., eK)</tt> crée d'abord un
            nouvel objet de classe <tt>cn</tt> comme ci-dessus, puis appelle
            sur cet objet la méthode <tt>constructor</tt> de la classe
            <tt>cn</tt>. À nouveau, le résultat est l'instance créée.
        </li></ul>
      <p></p>
            
      <p>
        Variables et attributs.
        </p><ul>
          <li> Les variables sont mutables, de même que les attributs
            des objets. </li>
          <li> Une variable globale déclarée au début du programme est
            visible dans tout le code du programme. Une variable locale
            décrite au début d'une méthode est visible exclusivement
            dans le code de cette méthode, et y masque une éventuelle
            variable globale de même nom. </li>
          <li> Un accès <tt>e.x</tt> suppose que la valeur de <tt>e</tt>
            est un objet dont la classe (ou une classe parente) possède
            un attribut de nom <tt>x</tt>. Lors d'un accès en écriture,
            la valeur de cet attribut doit être modifiée. </li>
        </ul>
      <p></p>

     <p>
        Méthodes.
        </p><ul>
          <li> L'évaluation d'un appel de méthode <tt>e.f(e1, ..., eK)</tt>
            suppose que la valeur de l'expression <tt>e</tt> est un objet,
            appartenant à une classe qui définit (ou hérite d')une méthode
            <tt>f</tt>. Pour choisir la méthode appelée, on cherche d'abord
            dans la classe de <tt>e</tt> elle-même, puis dans son éventuel
            parent, et ainsi de suite en remontant jusqu'à trouver une
            méthode du nom <tt>f</tt> demandé. C'est cette dernière qui est
            appelée, avec les paramètres explicites <tt>e1</tt> à <tt>eK</tt>.
            L'objet donné par <tt>e</tt> est également accessible durant
            l'évaluation de la méthode en tant que paramètre implicite
            (désigné par <tt>this</tt>).
          </li><li> Dans un appel de méthode <tt>e.f(e1, ..., eK)</tt>, l'ordre
            d'évaluation des expressions <tt>e</tt>, <tt>e1</tt>, ...,
            <tt>eK</tt> n'est pas spécifié. </li>
        </ul>
      <p></p>



      <h2 id="extensions"> Extensions </h2>

      <p>
        Voici une liste de suggestions d'extensions, concernant différents
        aspect de votre interprète. Cette liste n'est pas limitative.
      </p>

      <h3> Enrichissements du langage </h3>

      <h4> Champs immuables </h4>
      <p>
        Ajouter au langage la possibilité de déclarer un attribut
        <tt>final</tt>. La valeur d'un tel attribut ne peut pas être
        modifiée. Votre vérification des types devra donc s'assurer
        que seul le constructeur de la classe correspondante affecte
        une valeur à un tel attribut.
      </p>

      <h4> Visibilités </h4>
      <p>
        Ajouter au langage la possibilité de déclarer un attribut ou
        une méthode <tt>private</tt> ou <tt>protected</tt>.
        Un élément <tt>private</tt> ne doit alors être accessible que depuis
        le code de la classe courante. Un élément <tt>protected</tt> est
        accessible depuis le code de la classe courante ou de ses sous-classes
        (directes ou indirectes).
      </p>

      <h4> Déclarations en série </h4>
      <p>
        Ajouter la possibilité de déclarer simultanément plusieurs variables
        du même type, sous la forme
</p><pre>  var int x, y, z;
</pre>
      <p></p>

      <h4> Déclaration avec valeur initiale </h4>
      <p>
        Ajouter la possibilité, lors de la déclaration d'une variable ou
        d'un attribut, de lui fournir une valeur initiale, sous la forme
</p><pre>  var int x = 1;
</pre>
Dans le cas d'une variable globale (ou d'un attribut statique), cette
valeur est initialisée une fois pour toutes au début de l'interprétation.
Dans le cas d'une variable locale à une méthode, cette valeur
est initialisée au début de chaque appel. Dans le cas d'un attribut, cette
valeur est initialisée à chaque création d'une nouvelle instance.
      <p></p>

      <h4> Champs statiques </h4>
      <p>
        Ajouter au langage la possibilité de déclarer un attribut
        <tt>static</tt>. L'attribut n'est alors plus lié à chaque instance,
        mais à la classe elle-même, avec une valeur partagée pour toutes
        les instances.
      </p>

      <p>
        Note : la combinaison de <tt>static</tt> et <tt>final</tt>
        impose que l'attribut soit initialisé lors de sa déclaration
        (extension <b>déclaration avec valeur initiale</b>),
        et pas dans le constructeur.
      </p>

      <h4> Test de type </h4>
      <p>
        Ajouter au langage un opérateur <tt>instanceof</tt> testant le type
        dynamique d'un objet. Plus précisément, <tt>e instanceof t</tt> vaut
        <tt>true</tt> si <tt>e</tt> a pour valeur un objet dont le type
        <i>dynamique</i> est un sous-type de <tt>t</tt>.
      </p>

      <p>
        Note : pour l'essentiel, cet ajout concerne l'interprète.
        Cependant, dans certains cas il est possible dès le typage de
        prédire le résultat du test.
      </p>

      <h4> Transtypage </h4>
      <p>
        Ajouter au langage un opérateur de transtypage. 
        L'expression <tt>(t)e</tt> est essentiellement équivalente à
        l'expression <tt>e</tt> du point de vue de l'interprète, mais
        est considérée par le typeur comme ayant le type <tt>t</tt>.
      </p>

      <p>
        Plus précisément, on a les deux règles de typage suivantes :
</p><pre>  E |- e : t'     t' &lt;: t         E |- e : t'     t &lt;: t'
  -----------------------         -----------------------
       E |- (t)e : t                   E |- (t)e : t
</pre>
et l'expression est rejetée au typage si le type statique <tt>t'</tt>
de <tt>e</tt> et le type cible <tt>t</tt> ne sont pas sous-types l'un
de l'autre.
      <p></p>

      <p>
        En outre, on demande que l'interprète produise une erreur si
        le type dynamique de <tt>e</tt> n'est pas un sous-type de <tt>t</tt>,
        c'est-à-dire si la valeur de <tt>e</tt> n'est pas un objet
        d'une sous-classe de <tt>t</tt>. 
      </p>

      <p>
        Note : dans certains cas, ce dernier critère nécessite que
        l'interprète réalise un test du type dynamique de <tt>e</tt>.
        Dans d'autres cas, ce test est superflu (mais le faire ne pose
        pas de problème). Pour effectivement éviter de faire un test
        superflu, une possibilité est que le typeur "retire" l'opérateur
        de transtypage de l'AST lorsqu'il n'est pas nécessaire.
        Cette idée implique que le typeur ne se contente pas de vérifier
        qu'un programme est bien typé, mais également qu'il reconstruit
        une nouvelle version de l'AST qui peut être légèrement modifiée
        par rapport à la version issue de l'analyse syntaxique.
      </p>

      <h4> Super </h4>
      <p>
        Ajouter au langage la possibilité d'appeler une méthode <tt>f(...)</tt>
        avec la notation <tt>super.f(...)</tt>, pour appeler la version de la
        méthode <tt>f</tt> définie dans la classe mère.
      </p>

      <p>
        Note : un tel appel doit être rejeté par le typeur lorsque cette
        version mère de la méthode <tt>f</tt> n'existe pas.
      </p>

      <h4> Tableaux </h4>
      <p>
        Ajoutez au langage la possibilité de manipuler des tableaux homogènes
        (c'est-à-dire, dont tous les éléments sont du même type).
        Vous avez besoin :
        </p><ul>
          <li> d'un type pour les tableaux homogènes </li>
          <li> d'au moins une opération de création d'un tableau </li>
          <li> d'opérations d'accès en lecture et en écriture </li>
        </ul>
      <p></p>

      <h4> Égalité structurelle </h4>
      <p>
        Ajouter au langage un opérateur <tt>===</tt> d'égalité structurelle
        et sa négation <tt>=/=</tt>.
        L'égalité structurelle répond aux critères suivants :
        </p><ul>
          <li> chaque constante est égale à elle-même, </li>
          <li> deux objets sont égaux si et seulement si ils sont des instances
            de la même classe et ont pour chaque champ des valeurs structurellement
            égales, </li>
          <li> des valeurs de types différents ne sont pas comparables. </li>
        </ul>
      <p></p>

      <h4> Classes et méthodes abstraites </h4>
      <p>
        Ajouter au langage la possibilité de déclarer des classes abstraites
        et des méthodes abstraites (mot-clé <tt>abstract</tt>).
        Une méthode abstraite a une signature mais pas de code. Une classe
        contenant une méthode abstraite doit elle-même être abstraite, y
        compris lorsque cette méthode est héritée. Une classes héritant d'une
        méthode abstraite peut en revanche donner une définition à cette
        méthode (qui n'est alors plus abstraite dans cette classe).
        On ne peut pas utiliser l'opérateur <tt>new</tt> avec une classe
        abstraite.
      </p>

      <h4> Surcharge statique </h4>
      <p>
        Ajouter au langage la possibilité de définir plusieurs méthodes de même
        nom, différenciées par les types attendus pour les paramètres.
        Lors d'un appel de méthode <tt>e.f(e1, ..., eN)</tt>, il faut choisir
        la bonne version de <tt>f</tt> en fonction des types <i>statiques</i>
        des paramètres effectifs <tt>eK</tt>.
      </p>

      <p>
        Note : cette extension demande au typeur d'agir sur l'AST.
      </p>

      <p>
        Attention : en présence de sous-typage, il faut choisir parmi les
        méthodes compatibles avec les types statiques des paramètres, celle
        qui a le type "le plus précis". On échoue au typage s'il y a ambiguïté.
      </p>

      <h3> Raffinements de l'analyse </h3>

      <h4> Déclarations simplifiées </h4>
      <p>
        Assouplir le langage et adapter l'analyse syntaxique pour que les
        déclarations de variables, attributs et méthodes se fassent sans les
        mots-clés <tt>var</tt>, <tt>attribute</tt> et <tt>method</tt>
        (on obtient donc une syntaxe compatible avec java).
      </p>

      <p>
        Note : si vous retirez ces mots-clés sans rien changer d'autre,
        cela crée des conflits.
      </p>

      <h4> "Missing semicolon" </h4>
      <p>
        Faire que votre analyseur produise des messages d'erreurs
        spécifiques pour certaines erreurs de syntaxe fréquentes.
      </p>

      <h4> "Did you mean 'recursion'?" </h4>
      <p>
        Lorsque le programme tente d'accéder à un identifiant
        inexistant, produire un message d'erreur proposant un
        identifiant ressemblant, s'il en existe.
      </p>

      <h4> Le processus ne peut pas aboutir en raison d'un problème technique </h4>
      <p>
        En cas d'erreur au moment du typage, faire en sorte que le message
        d'erreur contienne des informations de localisation de l'erreur.
        Notez que cela demande d'agir sur la définition de la syntaxe abstraite,
        pour adjoindre à chaque élément des informations de localisation, et sur
        l'analyse syntaxique pour effectivement collecter ces informations.
      </p>

      <h4> Syntaxe abstraite typée </h4>
      <p>
        Modifier la phase de typage pour qu'au lieu de simplement vérifier
        que le programme est bien typé, elle produise une nouvelle version
        de l'AST où chaque expression est annotée par son type (statique).
      </p>

      <p>
        Comme l'extension précédente, cela nécessite de définir une variante
        de la syntaxe abstraite dans laquelle chaque expression peut être
        annotée.
      </p>

      <p>
        Voici une manière de définit en caml une syntaxe abstraite des
        expressions où chaque sous-expression porte une annotation d'un
        certain type <tt>t</tt>.
</p><pre>  type expr = { annot: t; expr: expr_ }
  and expr_ =
    | Int   of int
    | Bool  of bool
    | Binop of binop * expr * expr
    ...
</pre>
      <p></p>

    </div>
  </div>
  


</body></html>